클래스구성요소
  1) 클래스의 정의
	  - 필드(멤버변수, attribute)
	    클래스의 특성을 정의
	  - 메소드
	  - 생성자
  2) 클래스의 사용
     - 메모리에 사용할 클래스를 생성
     - 클래스를 JVM에서 사용하기 위해 메모리에 올리는 과정을 객체생성이라 한다. 혹은 인스턴스화라고 한다.
     - 메모리에 할당된 클래스를 객체, 인스턴스라 부른다.
     - 사용자정의클래스를 메모리에 할당
        사용자정의클래스 변수 = new 사용자정의클래스()
  3) 멤버변수
     - 멤버변수의 정의방법
     - 사용방법
     - 접근제한자
       클래스 내부에 선언된 멤버들을 외부에서 접근할 수 있도록 허용하기 위한 방법
       클래스를 정의할때 멤버변수는 private으로 정의하고 public메소드를 통해서 접근할 수 있도록 구현
       
       public : 변수가 선언된 클래스, 같은 패키지에 있는 클래스, 다른 패키지의 외부 클래스 모두 접근이 가능
       protected : 같은 패키지에 있는 클래스들, 다른 패키지에 있는 상속관계의 클래스만 접근이 가능
       default(키워드가 아니라 아무것도 선언하지 않은 상태) : 같은 패키지의 클래스만 접근 가능
       private : 변수가 선언된 클래스에서만 사용 가능
     
       
       
       
            
  4) 메소드
     - 메소드정의
       접근제한자 [특성을 나타내는 키워드] 리턴타입 메소드명(매개변수list...){
               ----------------- -----
               final, static,    리턴값이
               abstract,         없으면
               synchronized      void정의
                                 리턴값이 있으면 리턴값의 타입(기본형,참조형)
               
               
            [return 값]
            ------------
            리턴값이 있는 경우에만 추가하고 리턴할 수 있는 값은 1개만 가능 }   
     
  
  
       ex)
       public void myMethod(){
    
    
    
     - 메소드호출
     메소드가 정의되어 있는 클래스를 객체생성해서 객체를 참조하는 변수를 이용해서 접근
     메소드가정의된클래스 참조변수 = new 메소드가정의된클래스()
     참조변수.메소드명() -> 메소드의 호출
           --------
            사용하고 싶은 메소드의 매개변수가 있으면 매개변수에 전달할 값도 같이 정의해야 한다.
            
     
     
     
     
     
     - static
     - final
     - call by reference/call by value
  
  
  5) 생성자
     - 개요
     생성자는 메소드이다. 객체가 생성될때 한 번만 호출되는 특별한 메소드이며 이 메소드에서는 주로 자원에 대한 설정이나 해제 작업을 수행하거나
     객체가 가지고 있는 멤버변수를 초기화하는 작업을 처리한다.
     
     [객체생성]
     클래스타입 변수 = new 생성할클래스의생성자메소드()
     -------          --------------------
       ^                       ^
       |                       |___ 클래스 안에 미리 정의되어 있는 생성자 메소드를 호출
     사용할 클래스                      생성자 메소드도 일반 메소드처럼 외부에서 값을 입력받아 실행해야 하는 경우가 있으므로 일반메소드처럼 ()안에 
                                    데이터타입과 변수를 선언해서 정의할 수 있다.
                                    
     생성자메소드는 일반 메소드와 다르게 객체가 생성될때 한 번만 호출되는 메소드이므로 new연산자가 생성자메소드를 호출하면서 생성자메소드를 통해서
     메모리에 할당할 클래스가 어떤 클래스인지 파악하고 호출한다.
     따라서 생성자메소드를 정의할때 규칙이 존재한다는 의미
     생성자메소드에서는 주로 객체가 생성될때 필요한 로직을 수행(db연결, 네트워크접속, 파일오픈...) 하며 사용자가 만드는 클래스에서는 
     주로 멤버변수를 초기화하는 일을 처리하는 것이 일반적
     
     - 규칙
       0. 클래스를 작성하면서 생성자메소드를 정의하지 않으면 컴파일러가 기본생성자(매개변수가 없는 생성자)를 제공한다.
       1. 생성장메소드명은 클래스명과 대소문자까지 동일해야 한다.
       2. 리턴타입을 명시하지 않는다.
       3. 일반메소드와 동일하게 매개변수를 통해 외부에서 객체를 생성할때 값을 입력받아서 사용할 수 있다.
          => 매개변수 갯수나 타입을 다르게 하면 생성자메소드를 여러 개 정의할 수 있다.
             이를 생성자메소드 오버로딩이라 한다.
             
       4. 생성자메소드가 오버로딩되어 있는 경우 자기 자신의 생성자를 호출할 수 있다.
          생성자메소드 안에서 또 다른 생성자메소드를 호출할 수 있다.
          [문법]
          this를 활용 - this는 현재 작업중인 자기 자신의 객체를 의미
          this()는 현재 작업중인 자기 자신의 객체가 갖고 있는 생성자를 호출하라는 의미
          this(매개변수1, 매개변수2....)
          => 반드시 생성자메소드를 호출하는 명령문은 생성자메소드 내부에서 첫 번째 문장에 정의해야 한다.    
          
          
       5. 생성자메소드가 한 개 이상 정의되면 컴파일러는 기본생성자를 자동으로 만들어주지 않는다.
          => 기본생성자는 자바 프레임워크에서 자동으로 호출되는 경우가 있기 때문에 처리할 기능이 없어도 반드시 기본생성자는 항상 정의한다.
     
     - 생성자 작성방법
       public 클래스명(){
           //생성자메소드에서 처리할 명령문 }
     - 사용방법
                 
oop개요
oop특성
 1. 캡슐화(Encapsulation)
    - 객체가 갖고 있는 데이터를 private으로 정의하고 public메소드를 통해서 접근할 수 있도록 구현
   
    1) 객체의 통신
    2) 정보은닉(Information Hiding)
      - 멤버변수를 private으로 정의하기 때문에 외부에서 객체의 데이터를 접근할 수 없다.
    
 
 
 2. 상속(Inheritance)
 
 
 3. 다형성(Polymorphism)
   1) 상속
   2) 객체의 형변환
   3) 추상화
   4) 오버라이딩
   
 4. 인터페이스
  => 추상메소드만 보관하는 특별한 클래스
     인터페이스는 다중상속과 다형성을 적용하기 위한 목적으로 사용
     인터페이스는 상위클래스로 사용하며 객체 참조변수의 타입으로 정의하여 사용한다.
     
   1) 인터페이스는 interface 키워드를 이용해서 정의
   2) 인터페이스에 일반메소드를 정의할 수 없고 abstract메소드만 정의할 수 있다. 따라서 abstract클래스보다
      추상화정도가 높다.
   3) 인터페이스를 상속하는 경우 무조건 인터페이스가 갖고 있는 메소드를 모두 오버라이딩해야 한다.
      - 하위클래스에서 오버라이딩을 할때 자동으로 public이 추가되므로 생략이 가능
      - abstract키워드도 생략이 가능
   4) 클래스가 인터페이스를 상속하는 경우 implements를 이용해서 상속(구현)
   5) 인터페이스끼리 상속하는 경우 extends를 사용
   6) 인터페이스끼리는 다중상속이 가능
   7) 클래스가 클래스를 상속하고 인터페이스를 상속하려면 extends를 이용해서 클래스를 먼저 상속받고 인터페이스를 나중에 구현하도록 처리
      class 클래스명 extends 상위클래스 implements 인터페이스 {      }
   8) 클래스가 인터페이스를 상속(구현)하는 경우 다중 상속이 가능 ","로 상속할 인터페이스들을 나열
 
 
oop의 5원칙 (SOLID) 




